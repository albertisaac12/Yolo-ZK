{ "noir_version": "1.0.0-beta.2+1a2a08cbcb68646ff1aaef383cfc1798933c1355", "hash": 6286794191282811242, "abi": { "parameters": [{ "name": "embedding", "type": { "kind": "array", "length": 512, "type": { "kind": "field" } }, "visibility": "private" }, { "name": "enrolled", "type": { "kind": "array", "length": 512, "type": { "kind": "field" } }, "visibility": "private" }, { "name": "commitment_hash", "type": { "kind": "field" }, "visibility": "public" }], "return_type": null, "error_types": { "5748011963784534402": { "error_kind": "string", "string": "too far" }, "6485997221020871071": { "error_kind": "string", "string": "call to assert_max_bit_size" }, "16407765477254731130": { "error_kind": "string", "string": "commitment mismatch" }, "17843811134343075018": { "error_kind": "string", "string": "Stack too deep" } } }, "bytecode": "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", "debug_symbols": "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", "file_map": { "18": { "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    /// Safety: borrow is enforced to be boolean due to its type.\n    /// if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    /// if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        /// Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            /// Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        /// Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n", "path": "std/field/bn254.nr" }, "19": { "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n", "path": "std/field/mod.nr" }, "62": { "source": "\nuse dep::poseidon::poseidon2::Poseidon2;\n\nglobal N: u32 = 512; // Set it to 4 So that I can expriment with it revert back to 512\n\nfn main(embedding: [Field; N], enrolled: [Field; N], commitment_hash: pub Field) {\n    let threshold: Field = 10_000_000;\n\n    // Use Poseidon2 hash instead of bn254::sponge\n    let h = Poseidon2::hash(enrolled, enrolled.len());\n    assert(h == commitment_hash, \"commitment mismatch\");\n\n    let mut dist: Field = 0;\n    for i in 0..N {\n        let d = embedding[i] - enrolled[i];\n        dist += d * d;\n    }\n\n    assert(dist.lt(threshold), \"too far\");\n}\n", "path": "/home/qwerty/YoLo-Face/Yolo-ZK/embedding_proof_2/circuit/src/main.nr" }, "69": { "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n", "path": "/home/qwerty/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr" } }, "names": ["main"], "brillig_names": ["field_less_than", "decompose_hint", "lte_hint", "directive_invert"] }
