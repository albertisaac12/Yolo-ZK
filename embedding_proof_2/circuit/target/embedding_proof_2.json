{"noir_version":"1.0.0-beta.2+1a2a08cbcb68646ff1aaef383cfc1798933c1355","hash":8845297182448931081,"abi":{"parameters":[{"name":"embedding","type":{"kind":"array","length":512,"type":{"kind":"field"}},"visibility":"private"},{"name":"enrolled","type":{"kind":"array","length":512,"type":{"kind":"field"}},"visibility":"private"},{"name":"commitment_hash","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{"5748011963784534402":{"error_kind":"string","string":"too far"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"16407765477254731130":{"error_kind":"string","string":"commitment mismatch"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    /// Safety: borrow is enforced to be boolean due to its type.\n    /// if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    /// if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        /// Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            /// Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        /// Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"62":{"source":"\nuse dep::poseidon::poseidon2::Poseidon2;\n\nglobal N: u32 = 512; // Set it to 4 So that I can expriment with it revert back to 512\n\nfn main(embedding: [Field; N], enrolled: [Field; N], commitment_hash: pub Field) {\n    let threshold: Field = 10_000_000_000_000;\n\n    // Use Poseidon2 hash instead of bn254::sponge\n    let h = Poseidon2::hash(enrolled, enrolled.len());\n    assert(h == commitment_hash, \"commitment mismatch\");\n\n    let mut dist: Field = 0;\n    for i in 0..N {\n        let d = embedding[i] - enrolled[i];\n        dist += d * d;\n    }\n\n    assert(dist.lt(threshold), \"too far\");\n}\n","path":"/home/qwerty/YoLo-Face/Yolo-ZK/embedding_proof_2/circuit/src/main.nr"},"69":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/qwerty/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"names":["main"],"brillig_names":["field_less_than","decompose_hint","lte_hint","directive_invert"]}